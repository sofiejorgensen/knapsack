---
title: "lab_report_knapsack"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{lab_report_knapsack}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# The Knapsack Package
```{r setup}
library(knapsack)
library(tidyverse)
```

This vignette will examine the knapsack package that provides three different functions for solving the well-known discrete optimization problem called the knapsack problem, which can be formulated as follows: Imagine a knapsack that can carry a bunch of objects $i = 1,...,n$ up to a limited weight $W$, where each object has a weight $w_i$ and a value $v_i$. The task is to add objects to the knapsack and maximize the value without exceeding the limited weight. These three approaches whose functionality will be demonstrated are brute force search, dynamic programming and greedy heuristics, taking a \code{data.frame} and a knapsack weight \code{W} as parameters. 

## Settings

The knapsack package contains a preloaded data set with 2000 knapsack objects, ready to be optimized by one of the three functions. 

```{r}
head(knapsack_objects)
```

However for this purpose, we will generate three different \code{data.frames} containing different number of knapsack objects $n$, where each row corresponds to an object with columns representing the weights \code{w} and values\code{v}. To be more precise, we will generate three \code{data.frames} with $n=16$, $n=500$ and $n=1000000$ number of objects, respectively.  

```{r}
# Function to generate knapsack objects
knapsack_obj <- function(n){
  data.frame(w=sample(1:4000, size = n, replace = TRUE), v=runif(n = n, 0, 10000))
}

set.seed(42)
# The three data sets
obj_16 <- knapsack_obj(16)
obj_500 <- knapsack_obj(500)
obj_1000000 <- knapsack_obj(1000000)
```

In the upcoming sections, we will set the limited weight to $W=3500$. Also, we will be using the \code{proc.time} function to measure the running time of each function. 

## Brute force search

Brute force search goes through every single combination of objects to be able to maximize the value. The method guarantees that the value is maximized, but then you have to accept the complexity $0(2^n)$. Let us start by using the function \code{brute_force_knapsack()} with $n=16$ knapsack objects. 

```{r}
# Brute force search with n = 16
ptm <- proc.time()  
brute_force_knapsack(x = obj_16, W = 3500)
proc.time() - ptm
```


## Dynamic programming

We can benefit from the fact that the weights are discrete in this setup. This enables us to iterate over all possible values of $w$, to obtain the same results as the brute force, but with complexity $O(Wn)$.

```{r}
# Dynamic programming n = 500
ptm <- proc.time()
knapsack_dynamic(x = obj_16, W = 3500)
proc.time() - ptm
```

## Greedy heuristics

In contrast to the already explained algorithms, the greedy heuristics will return at least 50% of the true maximum value, but reduces the complexity to $O(n log n)$.

```{r}
# Greedy heuristics with n = 1000000
ptm <- proc.time()
greedy_knapsack(x = obj_1000000 , W = 3500)
proc.time() - ptm
```













