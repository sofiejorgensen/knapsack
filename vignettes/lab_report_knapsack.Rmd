---
title: "The knapsack package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{lab_report_knapsack}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(knapsack)
options(rmarkdown.html_vignette.check_title = FALSE)
```

This vignette will examine the knapsack package, that provides three different functions for solving the well-known discrete optimization problem called the knapsack problem, which can be formulated as follows: Imagine a knapsack that can carry a bunch of objects $i = 1,...,n$ up to a limited weight $W$, where each object has a weight $w_i$ and a value $v_i$. The task is to add objects to the knapsack and maximize the value without exceeding the limited weight. These three approaches whose functionality will be demonstrated are brute force search, dynamic programming and greedy heuristics, taking a `data.frame` with knapsack objects called `x`and a knapsack weight `W` as parameters.

## Settings

The knapsack package contains a preloaded data set with 2000 knapsack objects, ready to be optimized by one of the three functions. 



```{r}
data("knapsack_objects")
head(knapsack_objects)
```

However for this purpose, we will generate three different data frames containing different number of knapsack objects $n$, where each row corresponds to an object with columns representing the weight `w` and value `v`. To be more precise, we will generate three data frames with $n=16$, $n=500$ and $n=1000000$ number of objects, respectively.  

```{r}
# Function to generate knapsack objects
knapsack_obj <- function(n){
  data.frame(w=sample(1:4000, size = n, replace = TRUE), v=runif(n = n, 0, 10000))
}

set.seed(42)
# The three data sets
obj_16 <- knapsack_obj(16)
obj_500 <- knapsack_obj(500)
obj_1000000 <- knapsack_obj(1000000)
```

In the upcoming sections, we will set the limited weight to `W=3500`. Also, we will be using the `proc.time` function to measure the running time of each function. 

## Brute force search

Brute force search goes through every single combination of objects to be able to maximize the value. The method guarantees that the value is maximized, but then you have to accept the complexity $0(2^n)$. Let us start by using the function `brute_force_knapsack()` with $n=16$ knapsack objects. 

```{r}
# Brute force search with n = 16
ptm <- proc.time()  
brute_force_knapsack(x = obj_16, W = 3500)
t1 <- proc.time() - ptm
t1
```

The total value of the five elements `r brute_force_knapsack(x = obj_16, W = 3500)$elements` give the maximum value of `r format(brute_force_knapsack(x = obj_16, W = 3500)$value, scientific=FALSE)`. We can also see that the elapsed time is `r t1[3]` for $n=16$.


## Dynamic programming

We can benefit from the fact that the weights are discrete in this setup. This enables us to iterate over all possible values of $w$, to obtain the same results as the brute force, but with a better complexity $O(Wn)$. Now we increase the number of objects to $n=500$.

```{r}
# Dynamic programming n = 500
ptm <- proc.time()
knapsack_dynamic(x = obj_500, W = 3500)
t2 <- proc.time() - ptm
```

There are `r length(knapsack_dynamic(x = obj_500, W = 3500)$elements)` elements that maximize the value. The elapsed time is `r t2[3]` for $n=500$.


## Greedy heuristics

In contrast to the already explained algorithms, the greedy heuristics will return at least $50%$ of the true maximum value, but reduces the complexity to $O(n \log n)$.

```{r}
# Greedy heuristics with n = 1000000
ptm <- proc.time()
greedy_knapsack(x = obj_1000000 , W = 3500)
t3 <- proc.time() - ptm
```


In the final example we used $n = 1000000$ number of objects and the elapsed time is `r t3[3]`. From this we can conclude that it is much more time efficient compared to the other algorithms. The greedy heuristics performed a bit slower for $n = 1000000$ than brute force search for $n=16$. 





## Comparison

We suggest to use the greedy heuristics if you have a larger data set and accept not being able to get maximum value. In contrast, if you are interested in maximizing the value and if the weights take discrete values, then we recommend to use dynamic programming. However, brute force search will always return the maximum value and can be used unless the time efficiency is of the highest priority.

## Test suite 

The implementation of the greedy algorithm returns the same solution as the test suites.


## Profiling and optimizing the code

To increase the speed we will profile and optimize the code by using the package `lineprof` to identify bottlenecks. 

## Rubriks kub (*)

Hello 





